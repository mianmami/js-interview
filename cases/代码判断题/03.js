console.log(parseInt("2021-10-1"));  // 2021  有数字先解析数字，遇到不是数字的丢弃
console.log(parseInt("2021nowcoder")); // 2021
console.log(parseInt("nowcoder2021")); // NaN  如果一开始就不是数字，返回NaN

/* 
如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
*/

console.log(parseInt("0x123")); // 1 * 16 * 16 + 2 * 16 + 1 = 291

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


const a = {};
let b = {
  key: 'b'
}
let c = {
  key: 'c'
}
a[b] = 123
a[c] = 456
console.log(a[b]);  // 456

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

function test() {
  console.log(this);
}

let obj = {
  name: 'huang',
  test: test.bind(this)
}

obj.test() // window ，注意： test.bind(this) 这里的test是外面的函数，意思这里起始是执行了一遍，这里的上下文不是obj,而是windows，所以test函数里面的this指向windows

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

obj = {
  name: 'huang',
  test(){
    console.log(this); // obj 
  }, 
  test1: ()=>{
    console.log(this); // windows
  }
}
obj.test()
obj.test1() // 普通的函数调用this指向window,而箭头函数没有this,就指向其父级作用域中的this

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

let obj = {
  foo: function () {
    console.log(this)
  }
};
let bar = obj.foo
bar() // windows  可以理解为ojb.foo没有调用，而是复制了一份内容给bar，由bar调用。而bar调用的时候，执行栈的环境是window，所以此时就指向windows
obj.foo() // obj


// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

console.log(1 + - + + + - + 1 ) 
// 可以等价于 1 + 0 - 0 + 0 + 0 + 0 - 0 + 0 + 1 = 2

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

const a = {}
const b = {
  name: 'huang'
}
const c = {
  name: 'huang'
}
a[b] = 123
a[c] = 456
console.log(a[b]); // 123
// 注意：所有的以对象伪键的，统一都标记为[object object] 

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
var one   = 0.1
var two   = 0.2
var six   = 0.6
var eight = 0.8
[two - one == one, eight - six == two]   // true false  0.2和0.1成倍数关系，所以可以得到精确的数字(暂时这么理解)

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
let a = 123;
function fun1(){
  console.log(a);
}
function fun2(){
  let a = 456;
  fun1()
}
fun2() // 123, 函数的作用域是在定义函数的时候决定的，或者可以这样理解：fun1访问不到fun2里面的内容
